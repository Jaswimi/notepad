# notepad
## 数位DP
数位dp归为计数dp，通常需要统计一个区间[L,R]内满足某些限制条件的个数,会用到记忆化搜索

 - 求区间[l,r]内满足条件的数的个数 cnt[l,r] 通常转化为cnt[r]-cnt[l-1]
 - 求比345小的数的个数可以转化为:
  
  	- 最高位数填0~2,后两位随便填
  	- 最高位数填3,次高位数填0~3,最后一位随便填
  	- 前两位分别填3,4,最后一位填0~4
  	- 三位数分别填3,4,5


## Windy数
题目描述
不含前导零且相邻两个数字之差至少为 2 的正整数被称为 windy 数。windy 想知道，在 a 和 b 之间，包括 a 和 b ，总共有多少个 windy 数？

输入格式
输入只有一行两个整数，分别表示 a 和 b。

输出格式
输出一行一个整数表示答案。

#### 迭代
$dp[i][j]$表示 i 位数最高位取j的符合条件的个数
$dp[i][j] =\sum_{abs(j-k)>=2} dp[i-1][k] (0<=j,k<=9)$
比如dp[2][1]=dp[1][3]+dp[1][4]+dp[1][5]+...+dp[1][9]

 - 首先对DP数组进行初始化

```
void init(int n)
{
	memset(dp, 0, sizeof(dp));
	//当只有一位数的时候，dp[1][i]=1
	for (int i = 0; i <= 9; i++)
	{
		dp[1][i] = 1;
	}
	for (int i = 2; i < n; i++)//i位数
	{
		for (int j = 0; j <= 9; j++)//i位最高位取j
		{
			for (int k = 0; k <= 9; k++)//i-1位最高取k
			{
				if (abs(j - k) <= 2) continue;
				dp[i][j] += dp[i - 1][k];
			}
		}
	}
}
```
现在的dp数组已经处理完两位数相差2这个条件了,接着处理最大不超过n这个条件

 - 先计算位数小于len的数的个数
```
//计算位数小于len的数的个数
	for (int i = 1; i < len; i++)
	{
		for (int j = 1; j <= 9; j++)
		{
			ans += dp[i][j];
		}
	}
```
 - 计算最高位小于vec[len-1]的个数

	

```
//计算最高位小于vec[len-1]的数的个数
	for (int i = 1; i <= 9; i++)
	{
		ans += dp[len][i];
	}
	
```
 - 接着计算次高位小于vec[len-2]...一直到最后一位小于vec[0]的个数
 如果此时有两位连续的数确定,并且这两位数之差大于2,后面也就不用算了
 ```
 //计算第i+1位为vec[i],第i位小于vec[len-i]的数的个数
	for (int i = len - 1; i >= 1; i--)//i位数
	{
		for (int j = 0; j <vec[i-1]; j++)//最高位填j
		{
		    //j是比vec[i-1]小的数，将j与vec[i]也就是上一位进行对比，找出i-1位可以填的数
			if (abs(j - vec[i-1]) >= 2)
			{
				ans += dp[i][j];
			}
			
		}
		//如果高位有两位数不符合规则，则整个数就不会是windy数
		if (abs(vec[i] - vec[i-1]) >= 2)
			break;
		//到最后一位时,如果n的所有位都符合要求,那么答案个数加一
		if(i==1) ans++
	}
 ```
